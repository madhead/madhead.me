---
title: DRY и KISS
date: 2018-04-14T02:20:00+03:00
tags:
  - dry
  - kiss
  - programming
  - мысли
---

Пост о сложности исходного кода и бездумном следовании принципам разработки ПО (в частности, DRY).

<!--more-->

TODO::
  1. Слоты и чанки
  1. Пример из работы
  1. Проблемы примера
  1. Решение
  1. Защита решения
  1. Итоги и выводы

== Нейрофизиология 101

Под сложностью я буду понимать субъективную меру трудозатрат разработчика на понимание конкретного куска исходного кода.
Сколько времени ему потребуется, чтобы понять, что происходит на экране?
Умещается ли вообще происходящее на экран?
И, самое главное, умещается ли происходящие на экране в https://ru.wikipedia.org/wiki/Кратковременная_память[кратковременную] / https://ru.wikipedia.org/wiki/Рабочая_память[рабочую] память?

__Вообще, учёные склоняются к тому, что кратковременная память отличается от рабочей, но здесь это не так важно.
Если вкратце, то в кратковременной памяти данные лишь хранятся (запоминание продиктованного телефонного номер до момента его записи в список контактов), а в рабочей — ещё и обрабатываются (сравнение нескольких моделей телефонов из каталога по некоторым признакам).
Что гораздо более важно, так это то, что обьём и время хранения информации в кратковременной памяти ограничены.__

Объём кратковременной памяти составляет всего https://ru.wikipedia.org/wiki/Магическое_число_семь_плюс-минус_два[7 ± 2] элемента (а по последним данным и того меньше), а время хранения информации в ней — чуть меньше 20-ти секунд.

Негусто, правда?

Если нужно уместить в кратковременной памяти элементов сверх возможного, самый неиспользуемый будет "выброшен".
Забыт, если до этого был незнаком или помещён в https://ru.wikipedia.org/wiki/Долговременная_память[долговременную память], если был известен ранее.
Долговременная память, в свою очередь, делится на несколько уровней, различных по скорости доступа к информации: активный, пассивный и латентный.
Активный уровень самый быстрый, в нём хранится постоянно используемая информация.
Но всё же он далеко не так быстр, как кратковременная память.

__Кстати, когда какое-либо слово "вертится" у вас на языке — это и есть латентная долговременная память в действии.
Хорошие новости: вы действительно помните это слово; плохая — без подсказки его практически нереально извлечь.__

Здесь можно провести прямую аналогию с https://gist.github.com/jboner/2841832[этими числами, о которых должен знать каждый разработчик].
Кратковременная память — это кеш нашего CPU, мозга.
Активная долговременная память — чтение с SSD.
Пассивная — доступ к информации на HDD.
Латентная — отправка UDP-пакета по сети.

Надеюсь, теперь понятно, насколько кратковременная память ценна как ресурс.

И всё же, человеческий мозг — одна из самых удивительных штук в мире: в отличие от кремниевых пародий, обьём хранимой в неповторимом углеродном оригинале информации практически неограничен!
Я не зря использовал слово "элементы" ранее, ограничено именно их число, но не количество хранимой внутри информации.

Процесс, позволяющий легально проворачивать такие трюки, называется https://en.wikipedia.org/wiki/Chunking_(psychology)[чанкование].

== Фанки-чанки

#TODO#

При этом размер чанков не важен, важно их количество.
С одинаковой лёгкостью в слот для одного чанка помещается как целый алгоритм, так и отдельная его строка или всего одна изменяемая переменная.

Начну приводить примеры.
Допустим, нам необходимо найти максимальный элемент в массиве.
Два самых простых способа: завести переменную, проинициализировать её первым элементом массива, пробежаться по всему массиву, сравнивая её с текущим элементом из массива; или отсортировать массив и взять его первый (последний) элемент.
Думаю, вы поняли к чему я клоню: при всей возможной неэффективности второго способа он чрезвычайно прост для понимания.
На мой взгляд, первый алгоритм требует около трёх-четырёх слотов для чанков (переменная для результата, цикл, сравнение и присваивание в нём).
Второй — практически помещается в один чанк (вызывать алгоритм сортировки).
Грубо говоря, вариант с сортировкой в 3.5 раза проще!

Работая над какой-то задачей мы можем смещаться на разные уровни охвата.
В примере выше, в случае с алгоритмом с сортировкой массива, мы можем "нырнуть" на уровень ниже и попытаться вникнуть в сам алгоритм сортировки. Это неизбежно приведёт к "вылету" первоначальной задачи (нахождение максимального элемента) из кратковременной памяти. #РАЗВИТЬ#

Из чего же складывается сложность исходного кода.
У меня нет прямого и ясного ответа на этот вопрос, но, конечно же, имеет значение каждая мелочь: какие интерфейсы и классы наследует класс, как он используется, хранит ли какое-либо состояние (и изменяется ли оно) и т.д.
И горе вам, если вы адепт аспектов или какой-нибудь подобной магии.

Начнём с примера. С реального случая из моей дневной работы.
